import jax.numpy as jnp
import numpy as np
from dcegm.pre_processing.process_functions import (
    determine_function_arguments_and_partial_options,
)
from dcegm.pre_processing.process_model import _convert_params_to_dict
from jax import vmap
from toy_models.consumption_retirement_model.utility_functions import (
    utiility_func_log_crra,
)


def test_function_wrapping(load_example_model):
    params, _raw_options = load_example_model("deaton")
    options = {}

    options["model_params"] = _raw_options
    options.update(
        {
            "state_space": {
                "n_periods": 25,
                "choices": np.arange(2),
                "endogenous_states": {
                    "thus": np.arange(25),
                    "that": [0, 1],
                },
                "exogenous_processes": {
                    "ltc": {"states": np.array([0]), "transition": jnp.array([0])}
                },
            },
        }
    )

    params = _convert_params_to_dict(params)

    state_dict = {
        "consumption": jnp.arange(1, 7),
        "choice": jnp.arange(1, 7),
        "global_exog": np.zeros(6, dtype=int),
        "periods": jnp.arange(6),
    }

    util_expec = jnp.array(
        [0.0, 0.69314718, 1.09861229, 1.38629436, 1.60943791, 1.79175947], dtype=float
    )

    util_processed = determine_function_arguments_and_partial_options(
        utiility_func_log_crra,
        options,
    )

    calc_util = vmap(util_wrap, in_axes=(0, None, None))(
        state_dict, params, util_processed
    )
    assert jnp.allclose(calc_util, util_expec)


def util_wrap(state_dict, params, util_func):
    return util_func(**state_dict, params=params)
